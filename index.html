<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GlassSudoku v6.3 (High Impact)</title>
    <style>
        :root {
            --font-stack: -apple-system, BlinkMacSystemFont, "SF Pro Display", "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            
            /* --- iOS 26 LIQUID PALETTE --- */
            --glass-surface: rgba(255, 255, 255, 0.45); 
            --glass-border: rgba(255, 255, 255, 0.6);
            --glass-highlight: rgba(255, 255, 255, 0.9);
            --glass-shadow: 0 20px 50px rgba(0, 0, 0, 0.15), 0 10px 20px rgba(0,0,0,0.05);
            
            --text-primary: #1d1d1f; 
            --text-secondary: #86868b;
            
            --accent-color: #007AFF; 
            --accent-gradient: linear-gradient(135deg, #00C6FF, #0072FF);
            
            /* --- å¼·åŒ–å¾Œçš„æ‡¸æµ®ç‹€æ…‹ --- */
            /* 1. æ‡¸æµ®èƒŒæ™¯æ›´äº®ï¼Œæ¥è¿‘ç´”ç™½ï¼Œèˆ‡åº•å±¤æ‹‰é–‹å°æ¯” */
            --levitated-bg: #FFFFFF;
            /* 2. æ‡¸æµ®é™°å½±å¸¶æœ‰å¼·çƒˆé¡è‰²ï¼Œå¢å¼·ç«‹é«”æ„Ÿ */
            --levitated-shadow: 0 15px 30px rgba(0, 122, 255, 0.25), 0 5px 10px rgba(0, 122, 255, 0.1);
            
            --selected-bg: #FFFFFF;
            --selected-shadow: 0 25px 50px rgba(0, 122, 255, 0.4);
            
            --num-fixed: #1d1d1f;
            --num-user: #007AFF;
            --num-error: #FF3B30;
            
            --mouse-x: 0.5;
            --mouse-y: 0.5;
        }

        body {
            font-family: var(--font-stack);
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #f2f2f7;
            color: var(--text-primary);
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 20px 0;
            position: relative;
        }

        /* --- æ¶²æ…‹æµé«”èƒŒæ™¯ --- */
        .liquid-bg {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: -1;
            background: #ffffff; overflow: hidden;
        }
        .blob {
            position: absolute; filter: blur(80px); opacity: 0.8;
            animation: floatLiquid 20s infinite ease-in-out alternate;
            border-radius: 40% 60% 70% 30% / 40% 50% 60% 50%;
            will-change: transform, border-radius;
        }
        .blob:nth-child(1) { top: -10%; left: -10%; width: 50vw; height: 50vw; background: linear-gradient(135deg, #a8c0ff, #3f2b96); animation-duration: 25s; }
        .blob:nth-child(2) { bottom: -10%; right: -10%; width: 60vw; height: 60vw; background: linear-gradient(135deg, #4facfe, #00f2fe); animation-duration: 30s; animation-direction: alternate-reverse; }
        .blob:nth-child(3) { top: 40%; left: 40%; width: 40vw; height: 40vw; background: linear-gradient(135deg, #fbc2eb, #a6c1ee); opacity: 0.6; animation-duration: 20s; }
        @keyframes floatLiquid {
            0% { transform: translate(0, 0) rotate(0deg); }
            100% { transform: translate(30px, -50px) rotate(10deg); }
        }

        #confetti-canvas { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 100; }

        /* --- ä¸»ç»ç’ƒå¡ç‰‡ --- */
        .game-card {
            background: var(--glass-surface);
            backdrop-filter: blur(50px) saturate(180%);
            -webkit-backdrop-filter: blur(50px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-top: 1px solid rgba(255, 255, 255, 0.8);
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: var(--glass-shadow);
            border-radius: 40px; 
            padding: 32px;
            width: 90%;
            max-width: 440px;
            display: flex; flex-direction: column; align-items: center; position: relative;
            transform-style: preserve-3d;
            transform: perspective(1000px) rotateX(calc((var(--mouse-y) - 0.5) * 4deg)) rotateY(calc((var(--mouse-x) - 0.5) * -4deg));
            transition: transform 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        /* Header */
        .header { width: 100%; display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px; }
        .title {
            font-size: 2rem; font-weight: 700; color: var(--text-primary); letter-spacing: -0.02em;
            background: linear-gradient(to bottom, #1d1d1f 0%, #434344 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        .stats-area { display: flex; gap: 10px; font-size: 0.85rem; font-weight: 600; color: var(--text-secondary); }
        .stat-item { background: rgba(255,255,255,0.3); padding: 8px 14px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.5); backdrop-filter: blur(10px); }

        /* Controls */
        .controls { width: 100%; display: flex; gap: 10px; margin-bottom: 24px; justify-content: space-between; }
        .control-group { display: flex; gap: 8px; }
        select, button { font-family: var(--font-stack); font-weight: 600; cursor: pointer; outline: none; transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }
        select { padding: 8px 16px; border: none; background: rgba(255,255,255,0.5); border-radius: 14px; color: var(--text-primary); font-size: 0.9rem; box-shadow: 0 2px 10px rgba(0,0,0,0.03); appearance: none; -webkit-appearance: none; }
        .icon-btn { width: 44px; height: 44px; border-radius: 50%; background: rgba(255,255,255,0.5); border: 1px solid rgba(255,255,255,0.6); color: var(--text-primary); display: flex; align-items: center; justify-content: center; font-size: 1.2rem; box-shadow: 0 4px 12px rgba(0,0,0,0.05); }
        .icon-btn:hover { background: #fff; transform: scale(1.1); box-shadow: 0 8px 20px rgba(0,0,0,0.1); color: var(--accent-color); }
        .btn-new-game { background: var(--accent-gradient); color: #fff; border: none; padding: 0 20px; font-size: 0.95rem; border-radius: 20px; box-shadow: 0 4px 15px rgba(0, 122, 255, 0.3); text-shadow: 0 1px 2px rgba(0,0,0,0.2); }
        .btn-new-game:hover { transform: translateY(-2px) scale(1.02); box-shadow: 0 8px 25px rgba(0, 122, 255, 0.4); }

        /* Board Area */
        .board-wrapper {
            position: relative; width: 100%; aspect-ratio: 1; margin-bottom: 24px;
            border-radius: 24px; overflow: hidden; /* æ³¨æ„ï¼šè‹¥è¦æ ¼å­é£›å‡ºé‚Šç•Œï¼Œå¯èƒ½éœ€è¦èª¿æ•´ overflow */
            /* ç‚ºäº†é¿å…æ‡¸æµ®è¢«åˆ‡æ‰ï¼Œæˆ‘å€‘å¯ä»¥æŠŠ overflow: visible åŠ åˆ° board-wrapperï¼Œä½†è¦å°å¿ƒåœ“è§’ */
            /* åœ¨é€™å€‹è¨­è¨ˆä¸­ï¼Œç‚ºäº†ä¿æŒç»ç’ƒæ„Ÿï¼Œæˆ‘å€‘è®“å®ƒåœ¨å…§éƒ¨æ‡¸æµ®ï¼Œä½†åŠ å¼· padding */
            box-shadow: 0 20px 40px -10px rgba(0,0,0,0.1); 
            padding: 8px; /* å¢åŠ å…§è·ï¼Œçµ¦æ ¼å­æ›´å¤šæ‡¸æµ®ç©ºé–“ */
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.5);
        }
        .sudoku-board {
            display: grid; grid-template-columns: repeat(9, 1fr); grid-template-rows: repeat(9, 1fr);
            background: transparent; width: 100%; height: 100%; gap: 6px; /* å¢åŠ é–“éš™ï¼Œå¼·åŒ–ç¨ç«‹æ„Ÿ */
            border-radius: 18px;
            /* overflow: hidden; -> ç§»é™¤é€™å€‹ï¼Œè®“é™°å½±ä¸è¢«åˆ‡æ‰ */
        }
        
        .cell {
            background: rgba(255,255,255,0.5); 
            display: flex; align-items: center; justify-content: center;
            font-size: 1.6rem; cursor: pointer; position: relative;
            font-family: 'SF Pro Rounded', 'Arial Rounded MT Bold', sans-serif;
            border-radius: 8px;
            backdrop-filter: blur(5px);
            
            /* --- é—œéµç‰©ç†å¼•æ“èª¿æ•´ --- */
            /* ä½¿ç”¨ elastic (å½ˆæ€§) æ›²ç·šï¼šåƒæœå‡ä¸€æ¨£ Q å½ˆ */
            transition: 
                transform 0.5s cubic-bezier(0.68, -0.6, 0.32, 1.6), /* Bouncy overshoot */
                background-color 0.3s ease, 
                box-shadow 0.3s ease,
                border-radius 0.3s ease;
            z-index: 1; /* é»˜èªå±¤ç´š */
        }
        
        /* å€å¡Šåˆ†å‰² */
        .cell:nth-child(3n) { margin-right: 2px; }
        .cell:nth-child(9n) { margin-right: 0; }
        .cell:nth-child(n+19):nth-child(-n+27), .cell:nth-child(n+46):nth-child(-n+54) { margin-bottom: 2px; }

        .cell.fixed { font-weight: 700; color: var(--num-fixed); }
        .cell.user-input { color: var(--num-user); font-weight: 600; }
        
        /* --- é—œéµæ¨£å¼ï¼šå¼·åŠ›æ‡¸æµ®æ…‹ (Levitated) --- */
        .cell.levitated { 
            background-color: var(--levitated-bg); 
            /* æ”¾å¤§åˆ° 1.15 å€ï¼Œé€™æ˜¯éå¸¸æ˜é¡¯çš„è·³å‹• */
            transform: scale(1.15) translateZ(10px); 
            box-shadow: var(--levitated-shadow);
            z-index: 20; /* å±¤ç´šæ‹‰é«˜ */
            border-radius: 12px; /* è®Šåœ“æ½¤ */
            border: 2px solid rgba(0, 122, 255, 0.3); /* åŠ ä¸Šæ·¡æ·¡çš„è—è‰²é‚Šæ¡† */
        }
        
        /* --- é—œéµæ¨£å¼ï¼šè¶…ç´šé¸ä¸­æ…‹ (Selected) --- */
        .cell.selected {
            background-color: var(--selected-bg) !important;
            /* æ”¾å¤§åˆ° 1.25 å€ï¼Œéœ¸å è¦–è¦º */
            transform: scale(1.25) translateZ(30px);
            box-shadow: var(--selected-shadow);
            z-index: 30; /* æœ€é«˜å±¤ç´š */
            border-radius: 14px;
            color: var(--num-user) !important;
            border: 2px solid var(--accent-color); /* å¼·çƒˆé‚Šæ¡† */
        }
        
        .cell.error {
            background-color: rgba(255, 59, 48, 0.15) !important; color: var(--num-error) !important;
            animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both;
        }

        .notes-grid { position: absolute; top: 2px; left: 2px; right: 2px; bottom: 2px; display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); pointer-events: none; }
        .note-num { display: flex; align-items: center; justify-content: center; font-size: 0.6rem; color: var(--text-secondary); line-height: 1; font-weight: 600; opacity: 0.8; }
        .cell.selected .note-num { color: var(--accent-color); }

        /* Numpad & Overlays (Style maintained) */
        .numpad-container { width: 100%; }
        .mode-switch { width: 100%; margin-bottom: 20px; display: flex; gap: 4px; background: rgba(118, 118, 128, 0.12); padding: 4px; border-radius: 16px; }
        .mode-btn { flex: 1; padding: 10px; background: transparent; color: var(--text-primary); border: none; font-size: 0.9rem; border-radius: 12px; font-weight: 500; transition: all 0.2s ease; }
        .mode-btn.active { background: #fff; box-shadow: 0 3px 8px rgba(0,0,0,0.12), 0 3px 1px rgba(0,0,0,0.04); font-weight: 600; }
        .tools-row { display: flex; gap: 12px; margin-bottom: 20px; }
        .tool-btn { flex: 1; padding: 14px; border-radius: 16px; border: none; background: rgba(255,255,255,0.4); color: var(--text-primary); font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 6px; font-size: 0.9rem; transition: all 0.2s; box-shadow: 0 2px 10px rgba(0,0,0,0.02); }
        .tool-btn:hover { background: #fff; transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0,0,0,0.08); }
        .tool-btn.active { background: var(--text-primary); color: #fff; box-shadow: 0 5px 15px rgba(0,0,0,0.2); }
        .numpad { display: grid; grid-template-columns: repeat(5, 1fr); gap: 12px; }
        .num-btn { aspect-ratio: 1; border-radius: 16px; border: none; background: rgba(255,255,255,0.5); color: var(--num-user); font-size: 1.7rem; font-weight: 500; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 10px rgba(0,0,0,0.03); transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1); font-family: 'SF Pro Rounded', sans-serif; }
        .num-btn:hover { background: #fff; transform: translateY(-3px); box-shadow: 0 8px 20px rgba(0, 122, 255, 0.15); }
        .num-btn:active { transform: scale(0.9); }
        .num-btn.selected-digit { background: var(--accent-gradient); color: #fff; transform: scale(1.1); box-shadow: 0 10px 25px rgba(0, 122, 255, 0.4); }
        .num-btn.completed { opacity: 0.3; background: transparent; box-shadow: none; color: var(--text-secondary); cursor: default; }
        .num-btn.erase { color: var(--num-error); background: rgba(255, 59, 48, 0.1); }
        .num-btn.erase:hover { background: rgba(255, 59, 48, 0.2); box-shadow: 0 8px 20px rgba(255, 59, 48, 0.15); }
        .overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(255, 255, 255, 0.6); backdrop-filter: blur(20px); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 30; border-radius: 24px; }
        .overlay-title { font-size: 2rem; font-weight: 800; color: var(--text-primary); margin-bottom: 20px; letter-spacing: -0.5px; }
        .overlay-subtitle { font-size: 1.1rem; color: var(--text-secondary); margin-bottom: 30px; font-weight: 600; }
        @keyframes shake { 0% { transform: translateX(0); } 25% { transform: translateX(-4px); } 75% { transform: translateX(4px); } 100% { transform: translateX(0); } }
        @media (max-width: 480px) { body { padding: 10px; align-items: flex-start; } .game-card { padding: 24px 16px; width: 100%; border-radius: 30px; } .title { font-size: 1.6rem; } .cell { font-size: 1.4rem; } .num-btn { font-size: 1.5rem; border-radius: 14px; } }
    </style>
</head>
<body>

    <div class="liquid-bg">
        <div class="blob"></div>
        <div class="blob"></div>
        <div class="blob"></div>
    </div>

    <canvas id="confetti-canvas"></canvas>

    <div class="game-card" id="main-card">
        <div class="header">
            <div class="title">Sudoku Glass</div>
            <div class="stats-area">
                <div class="stat-item" title="éŒ¯èª¤æ¬¡æ•¸">
                    Errors: <span id="mistakeCount" style="color: var(--num-error)">0</span>/3
                </div>
                <div class="stat-item">
                    <span id="timer">00:00</span>
                </div>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <select id="difficulty">
                    <option value="30">Easy</option>
                    <option value="45" selected>Medium</option>
                    <option value="55">Hard</option>
                </select>
            </div>
            <div class="control-group">
                <button class="icon-btn" onclick="undo()" id="btn-undo" title="æ’¤éŠ· (Z)">â†º</button>
                <button class="icon-btn" onclick="togglePause()" title="æš«åœ/ç¹¼çºŒ">âšâš</button>
                <button class="icon-btn" onclick="toggleSound()" id="btn-sound" title="éŸ³æ•ˆ">ğŸ”Š</button>
                <button class="icon-btn" onclick="resetBoard()" title="é‡ç½®">â†»</button>
                <button class="btn-new-game" onclick="confirmNewGame()">New Game</button>
            </div>
        </div>

        <div class="board-wrapper">
            <div class="sudoku-board" id="board"></div>
            
            <div class="overlay" id="pausedOverlay">
                <div class="overlay-title">Paused</div>
                <button class="btn-new-game" onclick="togglePause()">Resume</button>
            </div>

            <div class="overlay" id="victoryOverlay">
                <div class="overlay-title" style="color: var(--accent-color);">Level Complete!</div>
                <div class="overlay-subtitle" id="victoryStats"></div>
                <button class="btn-new-game" onclick="confirmNewGame()">Next Level</button>
            </div>
        </div>

        <div class="numpad-container">
            <div class="mode-switch">
                <button class="mode-btn active" id="mode-cell" onclick="setMode('cell')">Cell First</button>
                <button class="mode-btn" id="mode-digit" onclick="setMode('digit')">Digit First</button>
            </div>

            <div class="tools-row">
                <button class="tool-btn" id="btn-pencil" onclick="togglePencilMode()">
                    âœ Note <span id="pencil-status" style="opacity:0.6; margin-left: 4px; font-size: 0.8em">OFF</span>
                </button>
                <button class="tool-btn" onclick="autoNotes()" title="è‡ªå‹•å¡«å…¥æ‰€æœ‰å€™é¸æ•¸">
                    ğŸ“ Auto Notes
                </button>
                <button class="tool-btn" onclick="getHint()">
                    ğŸ’¡ Hint (+20s)
                </button>
            </div>

            <div class="numpad">
                <button class="num-btn" id="btn-1" onclick="handleInput(1)">1</button>
                <button class="num-btn" id="btn-2" onclick="handleInput(2)">2</button>
                <button class="num-btn" id="btn-3" onclick="handleInput(3)">3</button>
                <button class="num-btn" id="btn-4" onclick="handleInput(4)">4</button>
                <button class="num-btn" id="btn-5" onclick="handleInput(5)">5</button>
                <button class="num-btn" id="btn-6" onclick="handleInput(6)">6</button>
                <button class="num-btn" id="btn-7" onclick="handleInput(7)">7</button>
                <button class="num-btn" id="btn-8" onclick="handleInput(8)">8</button>
                <button class="num-btn" id="btn-9" onclick="handleInput(9)">9</button>
                <button class="num-btn erase" onclick="handleInput(0)">âœ•</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('mousemove', (e) => {
            const x = e.clientX / window.innerWidth;
            const y = e.clientY / window.innerHeight;
            document.documentElement.style.setProperty('--mouse-x', x);
            document.documentElement.style.setProperty('--mouse-y', y);
        });

        const Confetti = {
            canvas: document.getElementById('confetti-canvas'),
            ctx: null, particles: [], animId: null,
            init: function() { this.ctx = this.canvas.getContext('2d'); this.resize(); window.addEventListener('resize', () => this.resize()); },
            resize: function() { this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; },
            start: function() { this.particles = []; for(let i=0; i<150; i++) { this.particles.push(this.createParticle()); } if(this.animId) cancelAnimationFrame(this.animId); this.animate(); },
            stop: function() { if(this.animId) cancelAnimationFrame(this.animId); this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); },
            createParticle: function() { return { x: Math.random() * this.canvas.width, y: Math.random() * this.canvas.height - this.canvas.height, vx: Math.random() * 4 - 2, vy: Math.random() * 4 + 2, color: `hsl(${Math.random()*360}, 90%, 60%)`, size: Math.random() * 8 + 4, rotation: Math.random() * 360, rotationSpeed: Math.random() * 10 - 5 }; },
            animate: function() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.particles.forEach((p) => {
                    p.x += p.vx; p.y += p.vy; p.rotation += p.rotationSpeed;
                    this.ctx.save(); this.ctx.translate(p.x, p.y); this.ctx.rotate(p.rotation * Math.PI / 180); this.ctx.fillStyle = p.color; this.ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size); this.ctx.restore();
                    if(p.y > this.canvas.height) { p.y = -10; p.x = Math.random() * this.canvas.width; }
                });
                this.animId = requestAnimationFrame(() => this.animate());
            }
        };
        Confetti.init();

        const SoundFX = {
            ctx: null, enabled: true,
            init: function() {
                try { if (!this.ctx) { const AC = window.AudioContext || window.webkitAudioContext; if(AC) this.ctx = new AC(); } if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume(); } catch(e) {}
            },
            playTone: function(freq, type, duration, vol = 0.1) {
                if (!this.enabled || !this.ctx) return;
                try { const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain(); osc.type = type; osc.frequency.setValueAtTime(freq, this.ctx.currentTime); gain.gain.setValueAtTime(vol, this.ctx.currentTime); gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration); osc.connect(gain); gain.connect(this.ctx.destination); osc.start(); osc.stop(this.ctx.currentTime + duration); } catch(e) {}
            },
            click: function() { this.playTone(600, 'sine', 0.05, 0.03); },
            input: function() { this.playTone(800, 'sine', 0.1, 0.05); },
            error: function() { this.playTone(180, 'triangle', 0.2, 0.1); },
            undo: function() { this.playTone(300, 'sine', 0.1, 0.05); },
            victory: function() { if (!this.enabled || !this.ctx) return; [523, 659, 784, 1046, 1318, 1568].forEach((f, i) => setTimeout(() => this.playTone(f, 'sine', 0.5, 0.1), i*100)); }
        };

        let grid = [], displayGrid = [], initialGrid = [], notesGrid = [], historyStack = [];
        let selectedCellIndex = -1, selectedDigit = -1, inputMode = 'cell', isPencilMode = false, mistakes = 0, isPaused = false, timerInterval, secondsElapsed = 0, gameActive = false;
        const STORAGE_KEY = 'glass_sudoku_v6_save';

        window.onload = function() {
            createBoardUI();
            if (!loadGame()) newGame();
            document.body.addEventListener('click', () => { if(SoundFX.enabled) SoundFX.init(); }, { once: true });
            document.addEventListener('click', (e) => {
                if (e.target.closest('.cell') || e.target.closest('.num-btn') || e.target.closest('.tools-row') || e.target.closest('.controls') || e.target.closest('.mode-switch') || e.target.closest('.overlay')) return;
                if (gameActive && !isPaused) { selectedCellIndex = -1; if(inputMode === 'digit') selectedDigit = -1; renderBoard(); updateNumpadStatus(); }
            });
            document.addEventListener("visibilitychange", () => { if (document.hidden && gameActive && !isPaused) togglePause(); });
            document.addEventListener('keydown', (e) => {
                if (isPaused || !gameActive) return;
                if(SoundFX.enabled) SoundFX.init();
                const key = e.key.toLowerCase();
                if (key === 'n') togglePencilMode(); if (key === 'm') toggleInputMode(); if ((e.ctrlKey || e.metaKey) && key === 'z') { e.preventDefault(); undo(); }
                if (e.key >= '1' && e.key <= '9') { if (e.shiftKey && inputMode === 'cell') { const t = isPencilMode; isPencilMode = true; handleInput(parseInt(e.key)); isPencilMode = t; } else { handleInput(parseInt(e.key)); } }
                else if (['Backspace', 'Delete', '0'].includes(e.key)) handleInput(0);
                else { if (['ArrowUp', 'w'].includes(key)) moveSelection('up'); else if (['ArrowDown', 's'].includes(key)) moveSelection('down'); else if (['ArrowLeft', 'a'].includes(key)) moveSelection('left'); else if (['ArrowRight', 'd'].includes(key)) moveSelection('right'); }
            });
            window.addEventListener('beforeunload', () => { if(gameActive) saveGame(); });
        };

        function createBoardUI() {
            const board = document.getElementById('board'); board.innerHTML = '';
            for (let i = 0; i < 81; i++) {
                let cell = document.createElement('div'); cell.className = 'cell'; cell.id = `cell-${i}`; cell.onclick = () => onCellClick(i);
                let notesDiv = document.createElement('div'); notesDiv.className = 'notes-grid';
                for(let n=1; n<=9; n++){ let s = document.createElement('span'); s.className = 'note-num'; s.id = `cell-${i}-note-${n}`; notesDiv.appendChild(s); }
                cell.appendChild(notesDiv); board.appendChild(cell);
            }
        }

        function setMode(mode) {
            inputMode = mode; document.getElementById('mode-cell').classList.toggle('active', mode === 'cell'); document.getElementById('mode-digit').classList.toggle('active', mode === 'digit'); SoundFX.click();
            if (mode === 'cell') { selectedDigit = -1; updateNumpadStatus(); if(selectedCellIndex === -1) selectedCellIndex = 0; } else { selectedCellIndex = -1; if(selectedDigit === -1) selectedDigit = 1; }
            renderBoard(); updateNumpadStatus();
        }
        function toggleInputMode() { setMode(inputMode === 'cell' ? 'digit' : 'cell'); }

        function handleInput(num) {
            if (!gameActive || isPaused) return;
            if (inputMode === 'cell') inputNumberIntoCell(selectedCellIndex, num);
            else { if (num === 0) return; selectedDigit = num; SoundFX.click(); renderBoard(); updateNumpadStatus(); }
        }

        function onCellClick(index) {
            if (!gameActive || isPaused) return;
            if (inputMode === 'cell') {
                selectedCellIndex = index;
                SoundFX.click();
                renderBoard();
            } else {
                if (selectedDigit !== -1) {
                    if (initialGrid[index] !== 0) { SoundFX.error(); return; }
                    const currentVal = displayGrid[index];
                    if (isPencilMode) inputNumberIntoCell(index, selectedDigit);
                    else { if (currentVal === selectedDigit) inputNumberIntoCell(index, 0); else inputNumberIntoCell(index, selectedDigit); }
                }
            }
        }

        function inputNumberIntoCell(idx, num) {
            if (idx === -1 || initialGrid[idx] !== 0) return;
            const currentVal = displayGrid[idx]; const currentNotes = new Set(notesGrid[idx]);
            if (isPencilMode) {
                if (num === 0) { if (notesGrid[idx].size > 0) { pushToHistory(idx, currentVal, currentNotes, 0, 'pencil'); notesGrid[idx].clear(); SoundFX.input(); } }
                else { pushToHistory(idx, currentVal, currentNotes, num, 'pencil'); if (notesGrid[idx].has(num)) notesGrid[idx].delete(num); else notesGrid[idx].add(num); SoundFX.input(); }
            } else {
                if (currentVal === num) return;
                pushToHistory(idx, currentVal, currentNotes, num, 'input');
                if (num === 0) { displayGrid[idx] = 0; SoundFX.input(); }
                else { displayGrid[idx] = num; notesGrid[idx].clear(); if (num !== window.solutionGrid[idx]) { mistakes++; updateMistakes(); SoundFX.error(); } else { clearRelatedNotes(idx, num); SoundFX.input(); checkCompletedNumber(num); } }
            }
            renderBoard(); updateNumpadStatus(); checkWinCondition(); saveGame();
        }

        function checkCompletedNumber(num) {
            let count = 0; displayGrid.forEach(n => { if (n === num) count++; });
            if (count >= 9 && inputMode === 'digit' && selectedDigit === num) { for(let i=1; i<=9; i++) { let c = 0; displayGrid.forEach(n => { if (n === i) c++; }); if (c < 9) { selectedDigit = i; updateNumpadStatus(); renderBoard(); return; } } selectedDigit = -1; }
        }

        function autoNotes() {
            if (!gameActive || isPaused) return; if(!confirm("Fill all candidates?")) return; SoundFX.click();
            for (let i = 0; i < 81; i++) { if (displayGrid[i] === 0) { notesGrid[i].clear(); for (let n = 1; n <= 9; n++) { if (checkIfSafe(Math.floor(i/9), i%9, n)) notesGrid[i].add(n); } } } renderBoard(); saveGame();
        }

        function renderBoard() {
            for (let i = 0; i < 81; i++) {
                const cell = document.getElementById(`cell-${i}`); const val = displayGrid[i]; 
                let classes = ['cell'];
                
                if (initialGrid[i] !== 0) classes.push('fixed'); else if (val !== 0) classes.push('user-input');
                if (val !== 0 && initialGrid[i] === 0 && val !== window.solutionGrid[i]) classes.push('error');
                
                if (inputMode === 'cell') {
                    if (i === selectedCellIndex) {
                        classes.push('selected');
                    } else if (selectedCellIndex !== -1) {
                        const selR = Math.floor(selectedCellIndex / 9);
                        const selC = selectedCellIndex % 9;
                        const selBoxR = Math.floor(selR / 3);
                        const selBoxC = Math.floor(selC / 3);
                        
                        const r = Math.floor(i / 9);
                        const c = i % 9;
                        const boxR = Math.floor(r / 3);
                        const boxC = Math.floor(c / 3);
                        
                        const selectedVal = displayGrid[selectedCellIndex];
                        let isRelated = false;
                        
                        if (selectedVal !== 0 && val === selectedVal) isRelated = true;
                        if (r === selR || c === selC || (boxR === selBoxR && boxC === selBoxC)) isRelated = true;
                        
                        if (isRelated) classes.push('levitated');
                    }
                } else {
                    if (selectedDigit !== -1 && val === selectedDigit) classes.push('levitated');
                }
                
                cell.className = ''; cell.classList.add(...classes);
                
                let contentHTML = ''; if (val !== 0) contentHTML = `<span class="cell-content-pop">${val}</span>`;
                const existingNotes = cell.querySelector('.notes-grid'); if(existingNotes) existingNotes.style.display = (val !== 0) ? 'none' : 'grid';
                let numSpan = cell.querySelector('.main-num'); if(!numSpan) { numSpan = document.createElement('span'); numSpan.className = 'main-num'; cell.appendChild(numSpan); }
                if(val !== 0) { if (numSpan.innerText !== String(val)) { numSpan.innerHTML = val; numSpan.classList.remove('cell-content-pop'); void numSpan.offsetWidth; numSpan.classList.add('cell-content-pop'); } } else { numSpan.innerHTML = ''; }
                if (val === 0) {
                    let notesDiv = cell.querySelector('.notes-grid'); if(!notesDiv) { notesDiv = document.createElement('div'); notesDiv.className = 'notes-grid'; for(let n=1; n<=9; n++){ let s = document.createElement('span'); s.className = 'note-num'; s.id = `cell-${i}-note-${n}`; notesDiv.appendChild(s); } cell.appendChild(notesDiv); }
                    notesDiv.style.display = 'grid'; for(let n=1; n<=9; n++) { const span = document.getElementById(`cell-${i}-note-${n}`); if(span) { span.innerText = notesGrid[i].has(n) ? n : ''; span.style.color = (inputMode === 'digit' && n === selectedDigit) ? 'var(--num-user)' : ''; span.style.fontWeight = (inputMode === 'digit' && n === selectedDigit) ? 'bold' : ''; } }
                }
            }
        }

        function updateNumpadStatus() {
            const counts = Array(10).fill(0); displayGrid.forEach(n => { if (n !== 0) counts[n]++; });
            for (let n = 1; n <= 9; n++) { const btn = document.getElementById(`btn-${n}`); btn.className = 'num-btn'; if (counts[n] >= 9) btn.classList.add('completed'); if (inputMode === 'digit' && selectedDigit === n) btn.classList.add('selected-digit'); }
        }

        function pushToHistory(index, oldVal, oldNotes, newVal, type) { historyStack.push({ index: index, oldVal: oldVal, oldNotes: new Set(oldNotes), newVal: newVal, type: type }); if (historyStack.length > 50) historyStack.shift(); document.getElementById('btn-undo').disabled = false; }
        function undo() { if (historyStack.length === 0 || !gameActive || isPaused) return; SoundFX.undo(); const action = historyStack.pop(); const idx = action.index; if (action.type === 'input') { displayGrid[idx] = action.oldVal; notesGrid[idx] = action.oldNotes; } else if (action.type === 'pencil') { notesGrid[idx] = action.oldNotes; } renderBoard(); updateNumpadStatus(); document.getElementById('btn-undo').disabled = historyStack.length === 0; saveGame(); }
        function generateSudoku(removeCount) { grid = Array(81).fill(0); fillDiagonal(); fillRemaining(0, 3); window.solutionGrid = [...grid]; displayGrid = [...grid]; let attempts = removeCount; while (attempts > 0) { let id = Math.floor(Math.random() * 81); if (displayGrid[id] !== 0) { displayGrid[id] = 0; attempts--; } } initialGrid = [...displayGrid]; }
        function fillDiagonal() { for (let i = 0; i < 9; i = i + 3) fillBox(i, i); }
        function unUsedInBox(rowStart, colStart, num) { for (let i = 0; i < 3; i++) for (let j = 0; j < 3; j++) if (grid[(rowStart + i) * 9 + (colStart + j)] === num) return false; return true; }
        function fillBox(row, col) { let num; for (let i = 0; i < 3; i++) for (let j = 0; j < 3; j++) { do { num = Math.floor(Math.random() * 9) + 1; } while (!unUsedInBox(row, col, num)); grid[(row + i) * 9 + (col + j)] = num; } }
        function checkIfSafe(i, j, num) { for (let k = 0; k < 9; k++) if (grid[i * 9 + k] === num) return false; for (let k = 0; k < 9; k++) if (grid[k * 9 + j] === num) return false; let rs = i - i % 3; let cs = j - j % 3; for (let k = 0; k < 3; k++) for (let l = 0; l < 3; l++) if (grid[(rs + k) * 9 + (cs + l)] === num) return false; return true; }
        function fillRemaining(i, j) { if (j >= 9 && i < 8) { i++; j = 0; } if (i >= 9 && j >= 9) return true; if (i < 3) { if (j < 3) j = 3; } else if (i < 6) { if (j === (Math.floor(i / 3)) * 3) j += 3; } else { if (j === 6) { i++; j = 0; if (i >= 9) return true; } } for (let num = 1; num <= 9; num++) { if (checkIfSafe(i, j, num)) { grid[i * 9 + j] = num; if (fillRemaining(i, j + 1)) return true; grid[i * 9 + j] = 0; } } return false; }
        function clearRelatedNotes(index, num) { const row = Math.floor(index / 9); const col = index % 9; const br = Math.floor(row / 3); const bc = Math.floor(col / 3); for (let i = 0; i < 81; i++) { if (i === index) continue; const r = Math.floor(i / 9); const c = i % 9; if (r === row || c === col || (Math.floor(r / 3) === br && Math.floor(c / 3) === bc)) { if (notesGrid[i].has(num)) notesGrid[i].delete(num); } } }
        function togglePencilMode() { SoundFX.click(); isPencilMode = !isPencilMode; const btn = document.getElementById('btn-pencil'); document.getElementById('pencil-status').innerText = isPencilMode ? "ON" : "OFF"; btn.classList.toggle('active', isPencilMode); }
        function togglePause() { if (!gameActive) return; SoundFX.click(); isPaused = !isPaused; document.getElementById('pausedOverlay').style.display = isPaused ? 'flex' : 'none'; if (isPaused) clearInterval(timerInterval); else startTimer(); }
        function toggleSound() { SoundFX.enabled = !SoundFX.enabled; document.getElementById('btn-sound').innerText = SoundFX.enabled ? 'ğŸ”Š' : 'ğŸ”‡'; if (SoundFX.enabled) SoundFX.init(); }
        function confirmNewGame() { SoundFX.click(); if (confirm("START NEW MISSION?")) newGame(); }
        function newGame() { try { localStorage.removeItem(STORAGE_KEY); } catch(e){} Confetti.stop(); generateSudoku(parseInt(document.getElementById('difficulty').value)); mistakes = 0; historyStack = []; secondsElapsed = 0; notesGrid = Array(81).fill().map(() => new Set()); inputMode = 'cell'; setMode('cell'); updateMistakes(); clearInterval(timerInterval); startTimer(); isPaused = false; gameActive = true; document.getElementById('pausedOverlay').style.display = 'none'; document.getElementById('victoryOverlay').style.display = 'none'; renderBoard(); saveGame(); }
        function resetBoard() { const confirmed = window.confirm("RESTART LEVEL?"); if(!confirmed) return; displayGrid = [...initialGrid]; notesGrid = Array(81).fill().map(() => new Set()); mistakes = 0; historyStack = []; updateMistakes(); renderBoard(); saveGame(); }
        function saveGame() { if (!gameActive) return; try { localStorage.setItem(STORAGE_KEY, JSON.stringify({ grid, displayGrid, initialGrid, notesGrid: notesGrid.map(s => Array.from(s)), historyStack, mistakes, secondsElapsed, difficulty: document.getElementById('difficulty').value })); } catch(e) {} }
        function loadGame() { try { const s = localStorage.getItem(STORAGE_KEY); if (!s) return false; const d = JSON.parse(s); grid = d.grid; displayGrid = d.displayGrid; initialGrid = d.initialGrid; window.solutionGrid = [...grid]; notesGrid = d.notesGrid.map(a => new Set(a)); historyStack = d.historyStack || []; mistakes = d.mistakes; secondsElapsed = d.secondsElapsed; document.getElementById('difficulty').value = d.difficulty || "45"; updateMistakes(); startTimer(); gameActive = true; isPaused = false; document.getElementById('pausedOverlay').style.display = 'none'; document.getElementById('victoryOverlay').style.display = 'none'; renderBoard(); return true; } catch { return false; } }
        function updateMistakes() { document.getElementById('mistakeCount').innerText = mistakes; if (mistakes >= 3) document.getElementById('mistakeCount').style.textShadow = "0 0 10px red"; }
        function startTimer() { clearInterval(timerInterval); timerInterval = setInterval(() => { secondsElapsed++; const m = Math.floor(secondsElapsed / 60).toString().padStart(2, '0'); const s = (secondsElapsed % 60).toString().padStart(2, '0'); document.getElementById('timer').innerText = `${m}:${s}`; }, 1000); }
        function checkWinCondition() { if (displayGrid.includes(0)) return; if (displayGrid.every((v, i) => v === window.solutionGrid[i])) { clearInterval(timerInterval); gameActive = false; try { localStorage.removeItem(STORAGE_KEY); } catch(e){} SoundFX.victory(); Confetti.start(); document.getElementById('victoryStats').innerText = `TIME: ${document.getElementById('timer').innerText} | ERRORS: ${mistakes}`; document.getElementById('victoryOverlay').style.display = 'flex'; } }
        function moveSelection(d) { if (selectedCellIndex === -1) { onCellClick(0); return; } let r = Math.floor(selectedCellIndex / 9), c = selectedCellIndex % 9; if (d === 'up') r = r > 0 ? r - 1 : 8; if (d === 'down') r = r < 8 ? r + 1 : 0; if (d === 'left') c = c > 0 ? c - 1 : 8; if (d === 'right') c = c < 8 ? c + 1 : 0; onCellClick(r * 9 + c); }
        function getHint() { if (!gameActive || isPaused) return; SoundFX.input(); let e = []; displayGrid.forEach((v, i) => { if (v === 0) e.push(i); }); if (e.length === 0) return; let i = e[Math.floor(Math.random() * e.length)]; pushToHistory(i, 0, new Set(notesGrid[i]), window.solutionGrid[i], 'input'); displayGrid[i] = window.solutionGrid[i]; notesGrid[i].clear(); secondsElapsed += 20; renderBoard(); updateNumpadStatus(); checkWinCondition(); saveGame(); }
    </script>
</body>
</html>
